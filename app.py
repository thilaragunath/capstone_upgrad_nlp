# -*- coding: utf-8 -*-
"""Try_App.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mPKSdzcelL6VxFoJQtmPnOxaOtKKugHG
"""

#import flask
import numpy as np
import pandas as pd
from flask import Flask, request, render_template
import pickle
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics.pairwise import pairwise_distances
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from numpy import *

#create an object
app = Flask(__name__)

input_data = pd.read_csv("sample30.csv")
input_data["reviews"] = input_data["reviews_title"]+". "+ input_data["reviews_text"]

def getUserFinalRating():
    response = ""
    d_df = input_data[["reviews_username","id","reviews_rating"]]
    
    d_df = d_df.groupby(by=["reviews_username","id"]).first().sort_values(by=["reviews_username","id"], ascending=True)
    d_df.columns = d_df.columns.to_series().apply(lambda x: x.strip())
    d_df.reset_index(inplace=True)
    train, test = train_test_split(d_df, test_size=0.30, random_state=42)
    df_pivot = train.pivot(index = "reviews_username", columns="id", values="reviews_rating").fillna(0)
    dummy_train = train.copy()
    dummy_train['reviews_rating'] = dummy_train['reviews_rating'].apply(lambda x: 0 if x>=1 else 1)
    #dummy_train["reviews_rating"].isnull().sum()
    # The movies not rated by user is marked as 1 for prediction.     
    # Convert the dummy train dataset into matrix format.
    dummy_train = dummy_train.pivot(index = "reviews_username", columns="id",values='reviews_rating').fillna(1)
    # user correlation
    user_correlation = 1 - pairwise_distances(df_pivot, metric='cosine')
    user_correlation[np.isnan(user_correlation)] = 0
    # Create a user-movie matrix. - Adjusted cosine
    df_pivot = train.pivot(index = "reviews_username", columns="id",values='reviews_rating')
    mean = np.nanmean(df_pivot, axis=1)
    df_subtracted = (df_pivot.T-mean).T
    user_correlation = 1 - pairwise_distances(df_subtracted.fillna(0), metric='cosine')
    user_correlation[np.isnan(user_correlation)] = 0
    user_correlation[user_correlation<0]=0
    #user_correlation
    user_predicted_ratings = np.dot(user_correlation, df_pivot.fillna(0))
    #user_predicted_ratings
    user_final_rating = np.multiply(user_predicted_ratings, dummy_train)
    if len(user_final_rating)>0:
        response = user_final_rating
    return response 
    
    
if __name__ == '__main__':    
    logreg = pickle.load(open("model.pkl", "rb"))
    vectorizer = pickle.load(open("vectorizer.pkl", "rb"))    
    user_final_rating = getUserFinalRating()


# create method to hit home web page
@app.route("/") #home page
def home():
    return render_template("index.html")

def getResults(final_features):  
    response = ""
    print("Hi! ",final_features[0])
    print("Welcome to ebass")
    print("\n")
    print("Processing the list of products that you might like to buy")  
    final_df= input_data.copy()
    user_input = final_df[final_df.reviews_username==final_features[0]]["reviews_username"].values[0]      
    
    d1 = user_final_rating.loc[user_input].sort_values(ascending=False)[0:20]            
    temp_df = final_df[final_df.id.isin(list(d1.index))][["id","reviews_username","name","reviews_rating","reviews","user_sentiment"]]
    print(temp_df.head(1))
    
    result = []
    for x in list(d1.index):
        
        validate_text = "".join(list(str(temp_df["reviews"][temp_df["id"]==x])))        
        list_of_userrating_0 = temp_df["reviews_rating"][(temp_df["id"]==x) & (temp_df["reviews_rating"]==0)].count().astype(int)
        list_of_userrating_1 = temp_df["reviews_rating"][(temp_df["id"]==x) & (temp_df["reviews_rating"]==1)].count().astype(int)
        list_of_userrating_2 = temp_df["reviews_rating"][(temp_df["id"]==x) & (temp_df["reviews_rating"]==2)].count().astype(int)
        list_of_userrating_3 = temp_df["reviews_rating"][(temp_df["id"]==x) & (temp_df["reviews_rating"]==3)].count().astype(int)
        list_of_userrating_4 = temp_df["reviews_rating"][(temp_df["id"]==x) & (temp_df["reviews_rating"]==4)].count().astype(int)
        list_of_userrating_5 = temp_df["reviews_rating"][(temp_df["id"]==x) & (temp_df["reviews_rating"]==5)].count().astype(int)
        
        name = list(set(temp_df["name"][temp_df["id"]==x]))[0]
        
        validate = vectorizer.transform([validate_text])
        predicted_prob_neg = logreg.predict_proba(validate).tolist()[0][0]
        predicted_prob_pos = logreg.predict_proba(validate).tolist()[0][1]
        predicted_sentiment = logreg.predict(validate).tolist()[0]
        result.append([x,name,predicted_sentiment,predicted_prob_neg,predicted_prob_pos,
                       [list_of_userrating_0,list_of_userrating_1,list_of_userrating_2,list_of_userrating_3,list_of_userrating_4,list_of_userrating_5]])  
      
    final_data = pd.DataFrame(result, columns=("id","name","predicted_sentiment","predicted_prob_neg","predicted_prob_pos","ratings"))
    final_data = final_data[(final_data.predicted_sentiment==1)].sort_values(by=["predicted_prob_pos"], ascending=False)
    print("\n")
    print("Recommended products are listed below!")
    print(final_data.name.to_string(index=False))
    print("\n")
    print("Top 5 best products")
    print("\n")
    for x in range(1,6):
        row = final_data[x-1:x]
        if len(row) >0:
            print(row.name.to_string(index=False))
            response = response + (row.name.to_string(index=False)) + "\n"
#            ratings = list(row.ratings)
#            print("checking",ratings)
#            data = {"Ratings": ["rate0","rate1","rate2","rate3","rate4","rate5"],"values":ratings[0]};
#            sns.barplot(y="Ratings", x="values", data=data, palette="autumn")
#            plt.xlabel("")
#            plt.ylabel("")
#            plt.show()  
    
    return response


@app.route("/predict", methods=["POST"])
def predict():
    features = [x for x in request.form.values()]    
    print(str(features))
    prediction = getResults(features)
    print(prediction)
    output=prediction
    return render_template("index.html", prediction_text="Recommended items {}".format(output))    

#run App
if __name__ == "__main__":
    app.run(debug=True)


    




